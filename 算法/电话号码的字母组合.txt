class Solution {
    private String[] letterMap= {
        " ", // 无用
        " ",
        "abc", // 2
        "def",  // 3
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz",
    };
    
    // 结果
    private LinkedList<String> output = new LinkedList<>();
    
    
    private void conbinations(String cms, String digitsNow) {
        //遍历到树的最底端开始output中添加值
        if (digitsNow.length() == 0) {
            output.add(cms.toString());
            return;
        }
        int numIndex = digitsNow.charAt(0) - '0';
        String toBeAdd = letterMap[numIndex];
        for(int i = 0; i < toBeAdd.length(); i++) {            // 每深入一层， 发散递归，来达到遍历该层节点的效果
            String added = toBeAdd.substring(i, i + 1);
            conbinations(cms + added, digitsNow.substring(1));  //递归调用每深一层，cms就会加上该层的对应字符
        }
    }
    
    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return output;
        }
        conbinations("", digits); //从空字符串开始
        return output;
    }
    
}