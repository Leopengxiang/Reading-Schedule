## 算法记录

时间 | 题名 | 解题要点 
-- | -- | --
2019.10.15 | three sum | 先排序后，选最小值为base， 双指针左右两端向中间走 
2019.10.15 | sum of two number | 链表题，设置守卫节点，以返回最终链表； 两数相加要注意处理进位， 短的链表假补0 
2019.10.16 | 最长不重复子字符串 | 滑动窗口， 双指针i，j; HashMap 
2019.10.16 | 翻转带符号整数 | 负数的余数也是负数。 
2019.10.18 | 两个有序数列的中位数 | 转换求两个数组中第k小值的问题， k/2这个值很重要
2019.10.19 | 最长回文子串 | 中心扩展， 双指针，奇数情况可看作左端右端均为同一点的偶数情况
2019.10.20 | Z字形变换| 定义StringBuffer数组，按行存放， 定义boolean类型的方向变量。
2019.10.27 | 盛水最多的容器| 双指针优化暴力解法
2019.11.01 | 数字转换成罗马数字| 贪心算法，从最大的开始减
2019.11.08 | 最长公共前缀 | 两两比较，求公共前缀； 或者所有字符串一起，从第一个字符开始对比，两层循环，需要使用标记的break 跳到最外层循环
2019.11.09 | 最接近的三数之和 | 排序后， 双指针
2019.11.10 | 电话号码的字母组合 | 利用递归穷尽每一种可能， 当然迭代也是可以解决这个穷尽问题的不过代码不太直观。
2019.11.11 | 四数之和 | 双指针， 去重条件是细节
2019.11.12 | 有效的括号 | 利用数据结构栈
2019.11.12 | 删除倒数第n个指针 | 快慢指针， 找到被删节点之前的那个节点
2019.11.13 | 合并两个有序列表 | 递归解法更加简洁明了，注意return;
2019.11.14 | 生成括号 | 暴力法，回溯法，动态规划法， 回溯法最优， 关键在于确定放置左右括号的限制条件，在用递归进行穷举。
2019.11.15 | 链表中的值两两交换 | 使用递归或者迭代均可，迭代要设置首部的哨兵节点， 两种方法的重点都是终止条件。
2019.11.16 | pow(x, n) | 二分法，主要通过保存值来避免重复计算。
2019.11.17 | 删除有序数组中的重复值 | 双指针， 保证走在后面的指针前面的数字都是不重复的
2019.11.18 | 矩阵随机翻转 | 傻逼题目
2019.11.19 | 合并n个有序链表 | 归并排序的思想，将数组进行两两合并， 时间复杂度nlogn
2019.11.20 | 删除数组中指定的元素 | 双指针
2019.11.21 | 实现Strstr() | 搞清楚==和equals
2019.11.22 |相同树 | 递归
2019.11.23 |对称树 | 左右子树互为镜像
2019.11.24 |最大数组子序 | 动态规划
2019.11.25 |爬楼梯 | 动态规划，斐波那契，数组存储
2019.11.26 |股票的最大利润 | 动态规划，要记住当前最大利润， 和当前最低股票价格。
2019.11.27 |最长的坡 | 暴力法并剔除一些条件
2019.11.28 |根到节点二进制数之和 | 数的递归遍历，深度优先 
2019.12.01 |有规律的二维数组中找数 | 要从右上角开始找，每找一次可以删除对应的行或列，来缩小寻找范围 
2019.12.07 |根据中序遍历数组和前序遍历数组重建二叉树 | 定义利用起始点和length来确定子数组的范围，basecase: length==0 时 返回null;
2019.12.08 |中序遍历的下一个节点 | 画图分情况
2019.12.09 |两个栈实现一个队列 | 两次后进先出就成了先进先出了
2019.12.10 |斐波那契数列 | 循环算
2019.12.11 |旋转数组 | 二分法，特殊情况情况值得深思
2019.12.12 |矩阵中的路径 | 回溯法， 遍历中的每一次伴随着一次递归的检查
2019.12.13 |机器人的路径 | 回溯法， DFS 
2019.12.14 |剪绳子 | 动态规划， 贪婪法 
2019.12.15 |二进制中1的个数 | 位运算 
2019.12.16 |数值的整数次方 | 考虑全面，指数为负数，指数为0， 当指数为负数，且底数为0时应该用try catch 做处理。 
2019.12.17 |打印从1到最大的n位数 | 大数问题， char[]储存数字解决溢出问题，利用字符来表示数字，并实现+1操作。 
2019.12.18 |删除链表中的重复节点 | 循环和递归都可解题，循环解题需要设置头节点。 
2019.12.26 |正则表达式匹配 | matchCore递归解决问题，不同情况的用或代表有可能的选择 。

# 2020 is arrived 

时间 | 题名 | 解题要点 
-- | -- | --
2020.1.4 |调整数组顺序使奇数位于偶数之前，且保持之前的奇数、偶数相对位置不变 | 牺牲时间，则是插入排序的思想，牺牲空间，则是两次遍历
2020.1.5 |链表中倒数第k个节点 | 代码的鲁棒性，链表为空与输入倒数的k>0，快慢指针
2020.1.6 |链表中的环入口 | 代码的完整性，分解问题，第一步确定有没有环，第二步确定环中的节点个数，第三部分快慢指针确定入口
2020.1.6 |反转链表 | 利用递归和迭代两种方法实现
2020.1.7 |合并两个有序链表 | 递归
2020.1.7 |树的子结构 | 分解问题，将问题分解为第一步，利用递归找到待查找树中找与子树相同的根节点，第二步 利用递归遍历，确定是否查找包含该子树。分为两个递归函数去解决问题 
2020.1.8 |镜像二叉树 | 在遍历树的时候，交换左右子树。利用迭代法解此题时需要借助队列完成二叉树的遍历
2020.1.8 |判断一颗二叉树是否是对称二叉树 | 左右子树是否镜像对称， 剑指offer：前序遍历和对称前序遍历的结果是否一致，根本思想一致，代码一致
2020.1.9 |顺时针打印矩阵 | 问题分解，画图找规律，并搞定边界条件
2020.1.9 |最小栈 | 思维方式的转变，以空间换时间
2020.1.10 |栈的压入、弹出序列 | 举例子，模拟压入弹出，使用辅助栈
2020.1.10 |从上到下打印二叉树 | 广度优先搜索
2020.1.11 |分行从上到下打印二叉树 | 增加两个状态变量、toPrint 这一行待打印的数目、nextLevelNum 下一行需打印的数目
2020.1.11 |之字形打印二叉树 | 通过举具体例子发现需要使用两个栈， 两个栈最好用数组来表示。找寻不同层子节点进栈的顺序的规律，**初始化完数组，别忘了初始化栈**。
2020.1.12 |二叉搜索树的后序遍历 | 最后一个节点时根节点，前面分为左右两部分， 左子树部分值全小于根节点，右子树值全大于根节点
2020.1.12 |二叉树路径中值的和为某数的所有路径 | 前序遍历 + 利用 ArrayList 来模拟栈 
2020.1.13 |复杂二叉树链表复制 | 先将复制的链表的节点挂在原链表节点之后
2020.1.13 |二叉搜索树转换为排序双向链表 | 二叉树的中序遍历，设置全局变量当前链表的最后一个值，与最终返回值这两个全局变量。
2020.1.14 |序列化二叉树 | 利用特殊符号如#标识null, 利用二叉树前序遍历的特点
2020.1.14 |字符串排列 | 递归，加动态规划
2020.1.15 |从n个字符中取出m个字符的组合情况| C（n, m） = C (n-1, m-1) + C (n-1, m)
2020.1.16 | 数组中出现次数超过一半的数字 | 防御性编程，确定确实这个数出现的次数要大于数组数量的一半
2020.1.16 |最小的K个数 | 容器法，或者使用partition, 基于随机快排的思想
2020.1.17 |数据流中的中位数 | 两个PQ, 插入为O（log(n)）, 但是找出只需要O（1）
2020.1.17 |连续子数组的最大和 | 定义两个sum, 一个preSum, 一个currentSum, currentSum < 0 时， 将currentSum 置为0


















