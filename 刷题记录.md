## 算法记录

时间 | 题名 | 解题要点 
-- | -- | --
2019.10.15 | three sum | 先排序后，选最小值为base， 双指针左右两端向中间走 
2019.10.15 | sum of two number | 链表题，设置守卫节点，以返回最终链表； 两数相加要注意处理进位， 短的链表假补0 
2019.10.16 | 最长不重复子字符串 | 滑动窗口， 双指针i，j; HashMap 
2019.10.16 | 翻转带符号整数 | 负数的余数也是负数。 
2019.10.18 | 两个有序数列的中位数 | 转换求两个数组中第k小值的问题， k/2这个值很重要
2019.10.19 | 最长回文子串 | 中心扩展， 双指针，奇数情况可看作左端右端均为同一点的偶数情况
2019.10.20 | Z字形变换| 定义StringBuffer数组，按行存放， 定义boolean类型的方向变量。
2019.10.27 | 盛水最多的容器| 双指针优化暴力解法
2019.11.01 | 数字转换成罗马数字| 贪心算法，从最大的开始减
2019.11.08 | 最长公共前缀 | 两两比较，求公共前缀； 或者所有字符串一起，从第一个字符开始对比，两层循环，需要使用标记的break 跳到最外层循环
2019.11.09 | 最接近的三数之和 | 排序后， 双指针
2019.11.10 | 电话号码的字母组合 | 利用递归穷尽每一种可能， 当然迭代也是可以解决这个穷尽问题的不过代码不太直观。
2019.11.11 | 四数之和 | 双指针， 去重条件是细节
2019.11.12 | 有效的括号 | 利用数据结构栈
2019.11.12 | 删除倒数第n个指针 | 快慢指针， 找到被删节点之前的那个节点
2019.11.13 | 合并两个有序列表 | 递归解法更加简洁明了，注意return;
2019.11.14 | 生成括号 | 暴力法，回溯法，动态规划法， 回溯法最优， 关键在于确定放置左右括号的限制条件，在用递归进行穷举。
2019.11.15 | 链表中的值两两交换 | 使用递归或者迭代均可，迭代要设置首部的哨兵节点， 两种方法的重点都是终止条件。
2019.11.16 | pow(x, n) | 二分法，主要通过保存值来避免重复计算。
2019.11.17 | 删除有序数组中的重复值 | 双指针， 保证走在后面的指针前面的数字都是不重复的
2019.11.18 | 矩阵随机翻转 | 傻逼题目
2019.11.19 | 合并n个有序链表 | 归并排序的思想，将数组进行两两合并， 时间复杂度nlogn
2019.11.20 | 删除数组中指定的元素 | 双指针
2019.11.21 | 实现Strstr() | 搞清楚==和equals
2019.11.22 |相同树 | 递归
2019.11.23 |对称树 | 左右子树互为镜像
2019.11.24 |最大数组子序 | 动态规划
2019.11.25 |爬楼梯 | 动态规划，斐波那契，数组存储
2019.11.26 |股票的最大利润 | 动态规划，要记住当前最大利润， 和当前最低股票价格。
2019.11.27 |最长的坡 | 暴力法并剔除一些条件
2019.11.28 |根到节点二进制数之和 | 数的递归遍历，深度优先 
2019.12.01 |有规律的二维数组中找数 | 要从右上角开始找，每找一次可以删除对应的行或列，来缩小寻找范围 
2019.12.07 |根据中序遍历数组和前序遍历数组重建二叉树 | 定义利用起始点和length来确定子数组的范围，basecase: length==0 时 返回null;
2019.12.08 |中序遍历的下一个节点 | 画图分情况
2019.12.09 |两个栈实现一个队列 | 两次后进先出就成了先进先出了
2019.12.10 |斐波那契数列 | 循环算
2019.12.11 |旋转数组 | 二分法，特殊情况情况值得深思
2019.12.12 |矩阵中的路径 | 回溯法， 遍历中的每一次伴随着一次递归的检查
2019.12.13 |机器的路径 | 回溯法， DFS 





